import type { UserObject, BackendJWT, BackendAccessJWT } from 'next-auth';
import { v4 as uuidv4 } from 'uuid';
import jwt from 'jsonwebtoken';
// import bcrypt from 'bcrypt';
import { z } from 'zod';
import dayjs from 'dayjs';

type UserMocked = {
  id: string;
  username: string;
  email: string;
  phone: string;
  passwordHash: string; // Store hashed password, not plain text!
};

// export type UserInJwt = {
//   id: number;
//   email: string;
// };

// 1. Define the Zod schema based on your existing UserInJwt type
//    (Adapt this to match your actual UserInJwt type definition)
const UserInJwtSchema = z.object({
  id: z.string(),
  email: z.string().email(),
});

// Infer the type from the schema (if you don't already have it)
type UserInJwt = z.infer<typeof UserInJwtSchema>;

const mockUsers: UserMocked[] = [
  {
    id: '1',
    username: 'ash',
    email: 'ash@example.com',
    phone: '607-888-0001',
    passwordHash: 'asdf',
  },
  {
    id: '2',
    username: 'atlas',
    email: 'atlas@example.com',
    phone: '607-888-0001',
    passwordHash: 'asdf',
  },
  {
    id: '102',
    username: 'nl',
    email: 'nl@outlook.com',
    phone: '607-888-0001',
    passwordHash: 'asdf',
  },
];

function hash(password: string): string {
  // fake
  //   // Replace with a proper hashing function like bcrypt in production
  //   const saltRounds = 10;
  //   const salt = bcrypt.genSaltSync(saltRounds);
  //   const hash = bcrypt.hashSync(password, salt);
  //   return hash;
  return password;
}

/**
 * Log in a user by sending a POST request to the backend using the supplied credentials.
 *
 * TODO: Implement the actual login functionality by sending a POST request to the backend
 *
 * @param email The email of the user
 * @param password The password of the user
 * @returns A BackendJWT response from the backend.
 */
export async function login(email: string, password: string): Promise<Response> {
  console.debug('Logging in');

  if (!email) {
    throw new Error('Email is required');
  }
  if (!password) {
    throw new Error('Password is required');
  }

  // mock checking the users in database by checking the mock list or hashmap
  const user = mockUsers.find((u) => u.email === email);
  if (!user) {
    throw new Error('Invalid credentials'); // User not found
  }
  const passwordMatch = hash(password) === user.passwordHash;
  if (!passwordMatch) {
    throw new Error('Invalid credentials'); // Incorrect password
  }

  const userInJwt: UserInJwt = {
    id: user.id,
    email: user.email,
  };

  // Dummy data to simulate a successful login
  const tokenData: BackendJWT = {
    access: generateAccessToken(userInJwt),
    refresh: generateRefreshToken(userInJwt),
  };

  return new Response(JSON.stringify(tokenData), {
    status: 200,
    headers: {
      'Content-type': 'application/json',
    },
  });
}

/**
 * Refresh the access token by sending a POST request to the backend using the supplied refresh token.
 *
 * TODO: Implement the actual refresh functionality by sending a POST request to the backend
 *
 * @param refreshToken The current refresh token
 * @returns A BackendAccessJWT response from the backend.
 */
export async function refresh(refreshToken: string): Promise<Response> {
  console.debug('Refreshing token');

  if (!refreshToken) {
    throw new Error('Token is required');
  }
  // Verify that the token is valid and not expired
  let userInJwt: UserInJwt;
  try {
    // Verify the JWT and decode the payload
    const decodedToken = jwt.verify(refreshToken, secret_signing_salt);

    // Attempt to parse the decoded token directly with the UserInJwtSchema
    userInJwt = UserInJwtSchema.parse(decodedToken);
  } catch (err) {
    throw new Error('Refresh token expired');
  }
  // const new_access_token: BackendAccessJWT = {
  //   access: generateAccessToken(userInJwt),
  // };
  const tokenData: BackendJWT = {
    access: generateAccessToken(userInJwt),
    refresh: generateRefreshToken(userInJwt),
  };
  return new Response(JSON.stringify(tokenData), {
    status: 200,
    headers: {
      'Content-type': 'application/json',
    },
  });
}

// Dummy secret salt for signing tokens
const secret_signing_salt = 'super-secret-salt';
// // Dummy user object
// const user: UserObject = {
//   id: 1,
//   email: 'user@email.com',
//   name: 'Mr User',
// };

// Dummy function to create an access token
const generateAccessToken = (user: UserInJwt): string => {
  // `iat` and `exp` are generated by the jwt library
  console.log('generateAccessToken', dayjs(Date.now()).format('HH:mm:ss.SSS'));
  console.log(user);
  return jwt.sign(
    {
      ...user,
      jti: uuidv4(),
    },
    secret_signing_salt,
    {
      algorithm: 'HS384',
      // @mark[token time]
      // Refresh token every 5 seconds for testing purposes
      expiresIn: '5s',
    }
  );
};
// Dummy function to create a refresh token
const generateRefreshToken = (user: UserInJwt): string => {
  // `iat` and `exp` are generated by the jwt library
  console.log('generateRefreshToken', dayjs(Date.now()).format('HH:mm:ss.SSS'));
  return jwt.sign(
    {
      ...user,
      jti: uuidv4(),
    },
    secret_signing_salt,
    {
      algorithm: 'HS384',
      // @mark[token time]
      // Expire refresh token every 2 minutes for testing purposes
      expiresIn: '2m',
    }
  );
};
